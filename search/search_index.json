{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Clip \u00b6 Documentation : https://erdnaxeli.github.io/clip/ Source code : https://github.com/erdnaxeli/clip/ Clip is a library for building CLI or CLI -like Crystal applications. A CLI -like application means any application that interacts with the user in a CLI style, like IRC bots. The major features of Clip are: Easy to write : All you need to write is a class (or struct). No new DSL to learn, and compilation time type validation. Easy to use : Make user friendly applications with standard behaviors and automatic error and help messages. You are in control : No code automatically executed for you, no messages printed to stdout. You do what you want, when you want. Requirements \u00b6 Crystal 0.36.0 or later. Clip depends only on the standard library. Installation \u00b6 Add the dependency to your shard.yml : dependencies : clip : github : erdnaxeli/clip Run shards install . Example \u00b6 Create a file named command.cr : require \"clip\" struct Command include Clip :: Mapper getter name : String end begin command = Command . parse rescue ex : Clip :: Error puts ex exit end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else puts \"Hello #{ command . name } \" end Build it and run it: $ crystal build command.cr $ ./command Error: argument is required: NAME $ ./command --help Usage: ./command [OPTIONS] NAME Arguments: NAME [required] Options: --help Show this message and exit. $ ./command Alice Hello Alice Advanced example \u00b6 Let's do a more advanced, with some commands. require \"clip\" abstract struct Command include Clip :: Mapper Clip . add_commands ({ \"hello\" => HelloCommand , \"goodbye\" => GoodbyeCommand , }) getter name : String end struct HelloCommand < Command include Clip :: Mapper end struct GoodbyeCommand < Command include Clip :: Mapper getter sad = false end begin command = Command . parse rescue ex : Clip :: Error puts ex exit end case command when HelloCommand puts \"Hello #{ command . name } \" when GoodbyeCommand if command . sad puts \"Goodbye #{ command . name } :'(\" else puts \"Goodbye #{ command . name } \" end when Clip :: Mapper :: Help puts command . help end It adds two commands: \"hello\" and \"goodbye\". $ crystal build command.cr $ ./command Error: you need to provide a command. $ ./command help Usage: ./command COMMAND [ARGS]... Commands: hello goodbye help Show this message and exit. $ ./command hello --help Usage: ./command hello [OPTIONS] NAME Arguments: NAME [required] Options: --help Show this message and exit. $ ./command hello Alice Hello Alice $ ./command goodbye --help Usage: ./command goodbye [OPTIONS] NAME Arguments: NAME [required] Options: --sad / --no-sad [default: false] --help Show this message and exit. $ ./command goodbye Alice Goodbye Alice $ ./command goodbye --sad Alice Goodbye Alice :'(","title":"Clip"},{"location":"#clip","text":"Documentation : https://erdnaxeli.github.io/clip/ Source code : https://github.com/erdnaxeli/clip/ Clip is a library for building CLI or CLI -like Crystal applications. A CLI -like application means any application that interacts with the user in a CLI style, like IRC bots. The major features of Clip are: Easy to write : All you need to write is a class (or struct). No new DSL to learn, and compilation time type validation. Easy to use : Make user friendly applications with standard behaviors and automatic error and help messages. You are in control : No code automatically executed for you, no messages printed to stdout. You do what you want, when you want.","title":"Clip"},{"location":"#requirements","text":"Crystal 0.36.0 or later. Clip depends only on the standard library.","title":"Requirements"},{"location":"#installation","text":"Add the dependency to your shard.yml : dependencies : clip : github : erdnaxeli/clip Run shards install .","title":"Installation"},{"location":"#example","text":"Create a file named command.cr : require \"clip\" struct Command include Clip :: Mapper getter name : String end begin command = Command . parse rescue ex : Clip :: Error puts ex exit end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else puts \"Hello #{ command . name } \" end Build it and run it: $ crystal build command.cr $ ./command Error: argument is required: NAME $ ./command --help Usage: ./command [OPTIONS] NAME Arguments: NAME [required] Options: --help Show this message and exit. $ ./command Alice Hello Alice","title":"Example"},{"location":"#advanced-example","text":"Let's do a more advanced, with some commands. require \"clip\" abstract struct Command include Clip :: Mapper Clip . add_commands ({ \"hello\" => HelloCommand , \"goodbye\" => GoodbyeCommand , }) getter name : String end struct HelloCommand < Command include Clip :: Mapper end struct GoodbyeCommand < Command include Clip :: Mapper getter sad = false end begin command = Command . parse rescue ex : Clip :: Error puts ex exit end case command when HelloCommand puts \"Hello #{ command . name } \" when GoodbyeCommand if command . sad puts \"Goodbye #{ command . name } :'(\" else puts \"Goodbye #{ command . name } \" end when Clip :: Mapper :: Help puts command . help end It adds two commands: \"hello\" and \"goodbye\". $ crystal build command.cr $ ./command Error: you need to provide a command. $ ./command help Usage: ./command COMMAND [ARGS]... Commands: hello goodbye help Show this message and exit. $ ./command hello --help Usage: ./command hello [OPTIONS] NAME Arguments: NAME [required] Options: --help Show this message and exit. $ ./command hello Alice Hello Alice $ ./command goodbye --help Usage: ./command goodbye [OPTIONS] NAME Arguments: NAME [required] Options: --sad / --no-sad [default: false] --help Show this message and exit. $ ./command goodbye Alice Goodbye Alice $ ./command goodbye --sad Alice Goodbye Alice :'(","title":"Advanced example"},{"location":"alternatives/","text":"Alternatives, inspirations and comparisons \u00b6 Clip is not the only library you can use to parse CLI parameters. Here are some alternatives and inspirations. Typer \u00b6 Typer is a library for building CLI applications that users will love using and developers will love creating. Typer is actually an awesome Python library. It inspired a lot Clip , whether for the idea of using type restrictions, the general behavior of the lib (what to consider an option or an argument, the help message), or even this documentation. OptionParser \u00b6 OptionParser is a class for command-line options processing. It works by using a specific DSL to execute blocks of code on command, options and arguments during the parsing. Admiral.cr \u00b6 A robust DSL for writing command line interfaces Admiral provides an easy way to define commands using inheritance and a DSL . Commander \u00b6 Command-line interface builder for the Crystal programming language. Commander provides a DSL to declare and use options, arguments, and commands. Clicr \u00b6 A simple declarative command line interface builder. Unlike to others presented libraries (and Clip ), Clicr is declarative: you call the library with a NamedTuple describing exactly what options, arguments and command you want.","title":"Alternatives"},{"location":"alternatives/#alternatives-inspirations-and-comparisons","text":"Clip is not the only library you can use to parse CLI parameters. Here are some alternatives and inspirations.","title":"Alternatives, inspirations and comparisons"},{"location":"alternatives/#typer","text":"Typer is a library for building CLI applications that users will love using and developers will love creating. Typer is actually an awesome Python library. It inspired a lot Clip , whether for the idea of using type restrictions, the general behavior of the lib (what to consider an option or an argument, the help message), or even this documentation.","title":"Typer"},{"location":"alternatives/#optionparser","text":"OptionParser is a class for command-line options processing. It works by using a specific DSL to execute blocks of code on command, options and arguments during the parsing.","title":"OptionParser"},{"location":"alternatives/#admiralcr","text":"A robust DSL for writing command line interfaces Admiral provides an easy way to define commands using inheritance and a DSL .","title":"Admiral.cr"},{"location":"alternatives/#commander","text":"Command-line interface builder for the Crystal programming language. Commander provides a DSL to declare and use options, arguments, and commands.","title":"Commander"},{"location":"alternatives/#clicr","text":"A simple declarative command line interface builder. Unlike to others presented libraries (and Clip ), Clicr is declarative: you call the library with a NamedTuple describing exactly what options, arguments and command you want.","title":"Clicr"},{"location":"contributing/","text":"Contributing \u00b6 Feel free to contribute to Clip ! If you spot a bug, you can open a pull request to fix it. If you are not sure how to do it, just open an issue to discuss about it. Here are some tips to develop on Clip , assuming you have already cloned the repository. Install the dependencies \u00b6 Don't forget to install the dependencies. There is only one so far, and it is a dev one, but it will be useful. $ shards install Resolving dependencies Fetching https://github.com/crystal-ameba/ameba.git Installing ameba (0.14.2) Postinstall of ameba: make bin && make run_file Develop your fix or feature \u00b6 Always remember to commit your modification on a separated branch. The majority of the Clip features are done with macros. Macros look like Crystal code, but they actually use a different language that is interpreted at compilation time by the compiler. The code is not easy to read, don't hesitate to ask for help! You may want to read the reference about macros and the macro module documentation . Write and run the tests \u00b6 Whether you fixed a bug or developed a new feature, you need to write a test to test the new behavior. Then run the tests: $ crystal spec ........................................................................................................................................ Finished in 5.95 milliseconds 136 examples, 0 failures, 0 errors, 0 pending Run static code analysis \u00b6 Ameba provides some hints about the code, to prevent wrong code constructions. Run it with: $ ./bin/ameba Inspecting 16 files ................ Finished in 279.16 milliseconds 17 inspected, 0 failure Warning There is currently an open issue on Ameba about Lint/ShadowingOuterLocalVar , you can skip this failure. Open a pull request \u00b6 Your code is now done, congrats! Your can open a pull request, I will try to look at it quickly :)","title":"Contributing"},{"location":"contributing/#contributing","text":"Feel free to contribute to Clip ! If you spot a bug, you can open a pull request to fix it. If you are not sure how to do it, just open an issue to discuss about it. Here are some tips to develop on Clip , assuming you have already cloned the repository.","title":"Contributing"},{"location":"contributing/#install-the-dependencies","text":"Don't forget to install the dependencies. There is only one so far, and it is a dev one, but it will be useful. $ shards install Resolving dependencies Fetching https://github.com/crystal-ameba/ameba.git Installing ameba (0.14.2) Postinstall of ameba: make bin && make run_file","title":"Install the dependencies"},{"location":"contributing/#develop-your-fix-or-feature","text":"Always remember to commit your modification on a separated branch. The majority of the Clip features are done with macros. Macros look like Crystal code, but they actually use a different language that is interpreted at compilation time by the compiler. The code is not easy to read, don't hesitate to ask for help! You may want to read the reference about macros and the macro module documentation .","title":"Develop your fix or feature"},{"location":"contributing/#write-and-run-the-tests","text":"Whether you fixed a bug or developed a new feature, you need to write a test to test the new behavior. Then run the tests: $ crystal spec ........................................................................................................................................ Finished in 5.95 milliseconds 136 examples, 0 failures, 0 errors, 0 pending","title":"Write and run the tests"},{"location":"contributing/#run-static-code-analysis","text":"Ameba provides some hints about the code, to prevent wrong code constructions. Run it with: $ ./bin/ameba Inspecting 16 files ................ Finished in 279.16 milliseconds 17 inspected, 0 failure Warning There is currently an open issue on Ameba about Lint/ShadowingOuterLocalVar , you can skip this failure.","title":"Run static code analysis"},{"location":"contributing/#open-a-pull-request","text":"Your code is now done, congrats! Your can open a pull request, I will try to look at it quickly :)","title":"Open a pull request"},{"location":"features/","text":"Features \u00b6 Static typing \u00b6 Clip uses a user defined type, struct or class, to infer what options and arguments should be parsed. The object returned by the Clip parsing method is just an instance of this type, hence you benefit from the type validation at compilation time. No DSL to learn \u00b6 There is no new DSL to learn to build applications with Clip . You want to add a string option? Just add an attribute with a type String . You want the option to have a default value? Just add a default value to the attribute. You already know how to do it. User friendly \u00b6 Clip allows you to build user friendly applications that respect standard behaviors. Anything you expect from a CLI application should work with Clip too: short and long options, flags, arguments, default values, multiple values, standard help messages, and many more. Not a CLI application framework \u00b6 Clip is about parsing CLI -like user input, but is not a framework to build CLI applications. It means that Clip does not run your application code for you, does not print anything for you, and can read the user input from any array of strings or just any string, not only ARGV . Not running your application code for you means that you are free to architecture you code as you like. Your command's code can take the parsed options and arguments as a parameter, and others parameters too, because you run it yourself, Clip does not. Not printing anything for you means that you can send errors and help messages to any medium, being STDOUT , a socket, or anything else. Reading the user input not only from ARGV means that you can use Clip to build applications that are not CLI applications . You can receive the user input from an HTTP call, an IRC message, a REPL , or whatever you want. Efficient \u00b6 Clip uses your type definition to write a parser and build the help message for each command. The parsers and the help messages are built at compilation time, which enabled Clip to have a minimal overhead at runtime. Tested \u00b6 The Clip repository contains 136 tests covering all its features, and all the documentation examples can be run \"as is\".","title":"Features"},{"location":"features/#features","text":"","title":"Features"},{"location":"features/#static-typing","text":"Clip uses a user defined type, struct or class, to infer what options and arguments should be parsed. The object returned by the Clip parsing method is just an instance of this type, hence you benefit from the type validation at compilation time.","title":"Static typing"},{"location":"features/#no-dsl-to-learn","text":"There is no new DSL to learn to build applications with Clip . You want to add a string option? Just add an attribute with a type String . You want the option to have a default value? Just add a default value to the attribute. You already know how to do it.","title":"No DSL to learn"},{"location":"features/#user-friendly","text":"Clip allows you to build user friendly applications that respect standard behaviors. Anything you expect from a CLI application should work with Clip too: short and long options, flags, arguments, default values, multiple values, standard help messages, and many more.","title":"User friendly"},{"location":"features/#not-a-cli-application-framework","text":"Clip is about parsing CLI -like user input, but is not a framework to build CLI applications. It means that Clip does not run your application code for you, does not print anything for you, and can read the user input from any array of strings or just any string, not only ARGV . Not running your application code for you means that you are free to architecture you code as you like. Your command's code can take the parsed options and arguments as a parameter, and others parameters too, because you run it yourself, Clip does not. Not printing anything for you means that you can send errors and help messages to any medium, being STDOUT , a socket, or anything else. Reading the user input not only from ARGV means that you can use Clip to build applications that are not CLI applications . You can receive the user input from an HTTP call, an IRC message, a REPL , or whatever you want.","title":"Not a CLI application framework"},{"location":"features/#efficient","text":"Clip uses your type definition to write a parser and build the help message for each command. The parsers and the help messages are built at compilation time, which enabled Clip to have a minimal overhead at runtime.","title":"Efficient"},{"location":"features/#tested","text":"The Clip repository contains 136 tests covering all its features, and all the documentation examples can be run \"as is\".","title":"Tested"},{"location":"help/","text":"Get help \u2014 Help Clip \u00b6 This project use github Discussions for community discussions. Don't hesitate to start a discussion if you need help! If you think you have found a bug, or you would like some new feature to be implemented, just open an issue :) If you like Clip , don't forget to \"star\" the repository on Github, it will help other users to known that it is useful.","title":"Get help \u2014 Help Clip"},{"location":"help/#get-help-help-clip","text":"This project use github Discussions for community discussions. Don't hesitate to start a discussion if you need help! If you think you have found a bug, or you would like some new feature to be implemented, just open an issue :) If you like Clip , don't forget to \"star\" the repository on Github, it will help other users to known that it is useful.","title":"Get help \u2014 Help Clip"},{"location":"release-notes/","text":"Release notes \u00b6 0.x \u00b6 0.2.4 \u00b6 Fix arguments parsing order to respect the idx instruction Support --help with nested command Support for name: nil with #help Fix array arguments in usage line Fix #help generated by .add_commands to support nil and the command's doc Add a #parse(String) method 0.2.3 \u00b6 fix the error message when an argument's value is invalid 0.2.2 \u00b6 fix errors' message the generated subclass Help now inherits from Clip::Mapper::Help fix a bug when calling a command with subcommands without specifying any command fix the help usage for commands (note that the subclass Help is not a singleton anymore) 0.2.1 \u00b6 all errors inherit from Clip::Error all errors have a correct message document the --help flag in the help message add a command help when there is commands 0.1.0 \u00b6 first public version","title":"Release notes"},{"location":"release-notes/#release-notes","text":"","title":"Release notes"},{"location":"release-notes/#0x","text":"","title":"0.x"},{"location":"release-notes/#024","text":"Fix arguments parsing order to respect the idx instruction Support --help with nested command Support for name: nil with #help Fix array arguments in usage line Fix #help generated by .add_commands to support nil and the command's doc Add a #parse(String) method","title":"0.2.4"},{"location":"release-notes/#023","text":"fix the error message when an argument's value is invalid","title":"0.2.3"},{"location":"release-notes/#022","text":"fix errors' message the generated subclass Help now inherits from Clip::Mapper::Help fix a bug when calling a command with subcommands without specifying any command fix the help usage for commands (note that the subclass Help is not a singleton anymore)","title":"0.2.2"},{"location":"release-notes/#021","text":"all errors inherit from Clip::Error all errors have a correct message document the --help flag in the help message add a command help when there is commands","title":"0.2.1"},{"location":"release-notes/#010","text":"first public version","title":"0.1.0"},{"location":"user%20guide/arrays/","text":"Multiple values \u00b6 You may want your options or arguments to accept multiple values. Think for example of ls or curl : $ curl --header \"X-First-Name: Jean\" --header \"X-Last-Name: Martin\" http://frenchexample.org/ $ ls file1 file2 file3 Here we gave 2 --headers options to curl , and 3 FILE argument to ls . Clip also supports that. We just declare our option or argument's type as an array. Options with multiple value \u00b6 require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper getter name = [ \"World\" ] end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name ) end end def self . hello ( name ) puts \"Hello #{ name . join ( \", \" ) } \" end end Myapplication . run $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] Options: --name TEXT [default: [World]] --help Show this message and exit. $ ./bin/myapplication Hello World $ ./bin/myapplication --name Alice --name Barbara --name Chlo\u00e9 Hello Alice, Barbara, Chlo\u00e9 Arguments with multiple values \u00b6 require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper getter name : Array ( String ) end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name ) end end def self . hello ( name ) puts \"Hello #{ name . join ( \", \" ) } \" end end Myapplication . run $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME... Arguments: NAME [required] Options: --help Show this message and exit. $ ./bin/myapplication Alice Barbara Chlo\u00e9 Hello Alice, Barbara, Chlo\u00e9 Supported types \u00b6 All the types supported for one value are supported for multiple values. The only exception is the type Bool , because it makes no sens to have a flag option repeated multiple times. The supported types are: array of all subtypes of Int array of all subtypes of Float Array(String) and all those types combined with Nil Default value \u00b6 Like with options and arguments with only one value, a multiple values options or arguments can have a default value. If so, it will not be required. If you want it to not have the message [default: [value]] in the help, just set the default value to nil . Warning If the default value is Array(String).new or [] of String , it will be shown as is in the help message. A better way is to make the type nilable and to set its default value to nil .","title":"Multiple values"},{"location":"user%20guide/arrays/#multiple-values","text":"You may want your options or arguments to accept multiple values. Think for example of ls or curl : $ curl --header \"X-First-Name: Jean\" --header \"X-Last-Name: Martin\" http://frenchexample.org/ $ ls file1 file2 file3 Here we gave 2 --headers options to curl , and 3 FILE argument to ls . Clip also supports that. We just declare our option or argument's type as an array.","title":"Multiple values"},{"location":"user%20guide/arrays/#options-with-multiple-value","text":"require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper getter name = [ \"World\" ] end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name ) end end def self . hello ( name ) puts \"Hello #{ name . join ( \", \" ) } \" end end Myapplication . run $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] Options: --name TEXT [default: [World]] --help Show this message and exit. $ ./bin/myapplication Hello World $ ./bin/myapplication --name Alice --name Barbara --name Chlo\u00e9 Hello Alice, Barbara, Chlo\u00e9","title":"Options with multiple value"},{"location":"user%20guide/arrays/#arguments-with-multiple-values","text":"require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper getter name : Array ( String ) end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name ) end end def self . hello ( name ) puts \"Hello #{ name . join ( \", \" ) } \" end end Myapplication . run $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME... Arguments: NAME [required] Options: --help Show this message and exit. $ ./bin/myapplication Alice Barbara Chlo\u00e9 Hello Alice, Barbara, Chlo\u00e9","title":"Arguments with multiple values"},{"location":"user%20guide/arrays/#supported-types","text":"All the types supported for one value are supported for multiple values. The only exception is the type Bool , because it makes no sens to have a flag option repeated multiple times. The supported types are: array of all subtypes of Int array of all subtypes of Float Array(String) and all those types combined with Nil","title":"Supported types"},{"location":"user%20guide/arrays/#default-value","text":"Like with options and arguments with only one value, a multiple values options or arguments can have a default value. If so, it will not be required. If you want it to not have the message [default: [value]] in the help, just set the default value to nil . Warning If the default value is Array(String).new or [] of String , it will be shown as is in the help message. A better way is to make the type nilable and to set its default value to nil .","title":"Default value"},{"location":"user%20guide/commands/","text":"Commands \u00b6 We have seen how to have options and arguments. Clip also supports commands . You have already used commands, as many CLI applications use them. For example shards has many commands: install and build are two of them, and you use them by typing shards install and shards build . A command has its own options and arguments. Actually, the struct Command that we used until now in this tutorial is already a command. Nesting other commands under an existing one requires: to define the new subcommands as their own type to register them inside the wrapping command using the Clip.add_command macro Commands nested with Clip.add_commands can also use Clip.add_commands to nest other commands. Clip does not enforce any limitation on the nesting level. Note Command are often called subcommands . Clip makes no actual distinction between the command on which we call #parse and the nested ones, so we just call them all commands . Let's change our application. We will move the actual behavior to a command hello and create a new one called goodbye . require \"clip\" module Myapplication VERSION = \"0.1.0\" abstract struct Command include Clip :: Mapper Clip . add_commands ({ \"hello\" => HelloCommand , \"goodbye\" => GoodbyeCommand , }) getter repeat = 1 getter name : String end struct HelloCommand < Command include Clip :: Mapper end struct GoodbyeCommand < Command include Clip :: Mapper @[ Clip::Option ( \"--yell\" ) ] getter yell : Bool? = nil end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end case command when Clip :: Mapper :: Help puts command . help when HelloCommand hello ( command . name , command . repeat ) when GoodbyeCommand goodbye ( command . name , command . repeat , command . yell ) end end def self . hello ( name , repeat ) repeat . times { puts \"Hello #{ name } \" } end def self . goodbye ( name , repeat , yell ) msg = \"Goodbye #{ name } \\n \" * repeat if yell puts msg . upcase else puts msg end end end Myapplication . run A lot has changed! We defined two new types: HelloCommand and GoodbyeCommand . Those types inherit from Command and define their own options and arguments. We keep the attributes repeat and name inside Command as both commands use them. We then register those types as nested commands under Command using Clip.add_commands . The Command#parse method changes to now dispatch the parsing to HelloCommand or GoodbyeCommand according to the user input. To check what command the user want to run, we use a case clause on the type of the returned object. Tip We used a Hash as the Clip.add_commands parameter but a NamedTuple would have worked too. Note Structs cannot be inherited, only abstract struct can, that's why Command is now abstract. But that's not a problem as it will never be instantiated now that it has nested commands. We can check that our two commands behave as expected: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication COMMAND [ARGS]... Commands: hello goodbye help Show this message and exit. $ ./bin/myapplication hello --help Usage: ./bin/myapplication hello [OPTIONS] NAME Arguments: NAME [required] Options: --repeat INTEGER [default: 1] --help Show this message and exit. $ ./bin/myapplication hello Alice Hello Alice $ ./bin/myapplication hello --repeat 2 Alice Hello Alice Hello Alice $ ./bin/myapplication goodbye --help Usage: ./bin/myapplication goodbye [OPTIONS] NAME Arguments: NAME [required] Options: --repeat INTEGER [default: 1] --yell --help Show this message and exit. $ ./bin/myapplication goodbye Alice Goodbye Alice $ ./bin/myapplication goodbye --repeat 2 --yell Alice GOODBYE ALICE GOODBYE ALICE You may have noticed that the first help message shows a command help but not an option --help . Indeed, as it is using commands, the help is now a command too. But to simplify the access to the help the --help option is still available, although not shown in the help message.","title":"Commands"},{"location":"user%20guide/commands/#commands","text":"We have seen how to have options and arguments. Clip also supports commands . You have already used commands, as many CLI applications use them. For example shards has many commands: install and build are two of them, and you use them by typing shards install and shards build . A command has its own options and arguments. Actually, the struct Command that we used until now in this tutorial is already a command. Nesting other commands under an existing one requires: to define the new subcommands as their own type to register them inside the wrapping command using the Clip.add_command macro Commands nested with Clip.add_commands can also use Clip.add_commands to nest other commands. Clip does not enforce any limitation on the nesting level. Note Command are often called subcommands . Clip makes no actual distinction between the command on which we call #parse and the nested ones, so we just call them all commands . Let's change our application. We will move the actual behavior to a command hello and create a new one called goodbye . require \"clip\" module Myapplication VERSION = \"0.1.0\" abstract struct Command include Clip :: Mapper Clip . add_commands ({ \"hello\" => HelloCommand , \"goodbye\" => GoodbyeCommand , }) getter repeat = 1 getter name : String end struct HelloCommand < Command include Clip :: Mapper end struct GoodbyeCommand < Command include Clip :: Mapper @[ Clip::Option ( \"--yell\" ) ] getter yell : Bool? = nil end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end case command when Clip :: Mapper :: Help puts command . help when HelloCommand hello ( command . name , command . repeat ) when GoodbyeCommand goodbye ( command . name , command . repeat , command . yell ) end end def self . hello ( name , repeat ) repeat . times { puts \"Hello #{ name } \" } end def self . goodbye ( name , repeat , yell ) msg = \"Goodbye #{ name } \\n \" * repeat if yell puts msg . upcase else puts msg end end end Myapplication . run A lot has changed! We defined two new types: HelloCommand and GoodbyeCommand . Those types inherit from Command and define their own options and arguments. We keep the attributes repeat and name inside Command as both commands use them. We then register those types as nested commands under Command using Clip.add_commands . The Command#parse method changes to now dispatch the parsing to HelloCommand or GoodbyeCommand according to the user input. To check what command the user want to run, we use a case clause on the type of the returned object. Tip We used a Hash as the Clip.add_commands parameter but a NamedTuple would have worked too. Note Structs cannot be inherited, only abstract struct can, that's why Command is now abstract. But that's not a problem as it will never be instantiated now that it has nested commands. We can check that our two commands behave as expected: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication COMMAND [ARGS]... Commands: hello goodbye help Show this message and exit. $ ./bin/myapplication hello --help Usage: ./bin/myapplication hello [OPTIONS] NAME Arguments: NAME [required] Options: --repeat INTEGER [default: 1] --help Show this message and exit. $ ./bin/myapplication hello Alice Hello Alice $ ./bin/myapplication hello --repeat 2 Alice Hello Alice Hello Alice $ ./bin/myapplication goodbye --help Usage: ./bin/myapplication goodbye [OPTIONS] NAME Arguments: NAME [required] Options: --repeat INTEGER [default: 1] --yell --help Show this message and exit. $ ./bin/myapplication goodbye Alice Goodbye Alice $ ./bin/myapplication goodbye --repeat 2 --yell Alice GOODBYE ALICE GOODBYE ALICE You may have noticed that the first help message shows a command help but not an option --help . Indeed, as it is using commands, the help is now a command too. But to simplify the access to the help the --help option is still available, although not shown in the help message.","title":"Commands"},{"location":"user%20guide/doc/","text":"Documentation \u00b6 An help message showing all available options and arguments is great, but an help message documenting them is better! Clip allows you to add a documentation to options, arguments, and commands, all using the same annotation Clip::Doc . Let's document our command: require \"clip\" module Myapplication VERSION = \"0.1.0\" @[ Clip::Doc ( \"Greet a person, one or many times.\" ) ] struct Command include Clip :: Mapper @[ Clip::Doc ( \"How many times to greet the person.\" ) ] getter repeat = 1 @[ Clip::Doc ( \"The name of the person to greet.\" ) ] getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) repeat . times { puts \"Hello #{ name } \" } end end Myapplication . run See how beautiful our help is now: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Greet a person, one or many times. Arguments: NAME The name of the person to greet. [required] Options: --repeat INTEGER How many times to greet the person. [default: 1] --help Show this message and exit. You may have noticed that the documentation for both options --repeat and --help are aligned. If you have many arguments, their documentation will be aligned too. If a documentation is too big to fit in a 80 chars long line, it is nicely wrapped: require \"clip\" module Myapplication VERSION = \"0.1.0\" @[ Clip::Doc ( \"Greet a person, one or many times. This fictitious command \" \\ \"is actually used to demonstrated all the capabilities of \" \\ \"Clip, a Crystal library to deserialize CLI parameters to \" \\ \"a user defined object.\" ) ] struct Command include Clip :: Mapper @[ Clip::Doc ( \"How many times to greet the person. Note that greeting \" \\ \"someone too many times in a row could be really annoying, \" \\ \"and you should probably no do that in real life, unless \" \\ \"you are a sitcom character.\" ) ] getter repeat = 1 @[ Clip::Doc ( \"The name of the person to greet.\" ) ] getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) repeat . times { puts \"Hello #{ name } \" } end end Myapplication . run The command's doc and the --repeat option's doc are nicely wrapped: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Greet a person, one or many times. This fictitious command is actually used to demonstrated all the capabilities of Clip, a Crystal library to deserialize CLI parameters to a user defined type. Arguments: NAME The name of the person to greet. [required] Options: --repeat INTEGER How many times to greet the person. Note that greeting someone too many times in a row could be really annoying, and you should probably no do that in real life, unless you are a sitcom character. [default: 1] --help Show this message and exit.","title":"Documentation"},{"location":"user%20guide/doc/#documentation","text":"An help message showing all available options and arguments is great, but an help message documenting them is better! Clip allows you to add a documentation to options, arguments, and commands, all using the same annotation Clip::Doc . Let's document our command: require \"clip\" module Myapplication VERSION = \"0.1.0\" @[ Clip::Doc ( \"Greet a person, one or many times.\" ) ] struct Command include Clip :: Mapper @[ Clip::Doc ( \"How many times to greet the person.\" ) ] getter repeat = 1 @[ Clip::Doc ( \"The name of the person to greet.\" ) ] getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) repeat . times { puts \"Hello #{ name } \" } end end Myapplication . run See how beautiful our help is now: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Greet a person, one or many times. Arguments: NAME The name of the person to greet. [required] Options: --repeat INTEGER How many times to greet the person. [default: 1] --help Show this message and exit. You may have noticed that the documentation for both options --repeat and --help are aligned. If you have many arguments, their documentation will be aligned too. If a documentation is too big to fit in a 80 chars long line, it is nicely wrapped: require \"clip\" module Myapplication VERSION = \"0.1.0\" @[ Clip::Doc ( \"Greet a person, one or many times. This fictitious command \" \\ \"is actually used to demonstrated all the capabilities of \" \\ \"Clip, a Crystal library to deserialize CLI parameters to \" \\ \"a user defined object.\" ) ] struct Command include Clip :: Mapper @[ Clip::Doc ( \"How many times to greet the person. Note that greeting \" \\ \"someone too many times in a row could be really annoying, \" \\ \"and you should probably no do that in real life, unless \" \\ \"you are a sitcom character.\" ) ] getter repeat = 1 @[ Clip::Doc ( \"The name of the person to greet.\" ) ] getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) repeat . times { puts \"Hello #{ name } \" } end end Myapplication . run The command's doc and the --repeat option's doc are nicely wrapped: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Greet a person, one or many times. This fictitious command is actually used to demonstrated all the capabilities of Clip, a Crystal library to deserialize CLI parameters to a user defined type. Arguments: NAME The name of the person to greet. [required] Options: --repeat INTEGER How many times to greet the person. Note that greeting someone too many times in a row could be really annoying, and you should probably no do that in real life, unless you are a sitcom character. [default: 1] --help Show this message and exit.","title":"Documentation"},{"location":"user%20guide/errors/","text":"Errors \u00b6 When calling #parse you should always rescue errors, unless you want your application to crash in a bad way. The method can raises 3 different errors. Those errors have two common properties: they inherit from Clip::Error their message is preformatted and can be shown directly to the user The first property means you can rescue only Clip::Errors , and the second one means you can do puts ex or ex.to_s (where ex is the rescued exception) and you will have a nice message. Note Clip does not provide any i18n support for now, so all messages are in english. Parsing error \u00b6 If the parsing of options and arguments failed, a Clip::ParsingError exception is raised. The exception's message is already a ready-to-use message that you can present to the user, but the exception also provides a way to know what happens exactly. Options parsing error \u00b6 The errors related to options parsing are accessible with Clip::ParsingError#options . It returns a Hash(String, Clip::Errors) The key is the name of the option which triggered the error. If the option was present in the user input, the name used will be kept. If not, there are two cases: either the option has no names specified with the Clip::Option annotation and the default one is used, or the first name in the annotation is used. The possible errors are: Clip::Errors::InvalidValue : the value provided for the option is invalid. It could be triggered when integers or floats are expected. Clip::Errors::MissingValue : a value must be provided for the option but there is no value. Clip::Errors::Required : the option is required but is not provided. Clip::Errors::Unknown : the provided option is unknown. Arguments parsing error \u00b6 In the same way, errors related to arguments parsing are accessible with Clip::ParsingError#arguments . It returns a Hash(String, Clip::Errors) . The key is the name of the argument. The possible errors are: Clip::Errors::InvalidValue : the value provided for the argument is invalid. It could be triggered when integers or floats are expected. Clip::Errors::Required : the argument is required but is not provided. Excess arguments are ignored, hence you will never get an Unknown error. Example \u00b6 require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Option ( \"-r\" , \"--repeat\" ) ] getter repeat = 1 @[ Clip::Option ] getter yell : Bool getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: ParsingError pp! ex . options , ex . arguments end end end Myapplication . run $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --repeat ex.options # => {\"--yell\" => Required, \"--repeat\" => MissingValue} ex.arguments # => {\"name\" => Required} $ ./bin/myapplication --yell -r yes --name Alice Barbara ex.options # => {\"-r\" => InvalidValue, \"--name\" => Unknown} ex.arguments # => {} Nested commands error \u00b6 When using nested commands, two exceptions can be raised: Clip::MissingCommand : a nested command is expected but none is provided. Clip::UnknownCommand : the provided nested command is unknown. The command is accessible with Clip::UnknownCommand.command . require \"clip\" module Myapplication VERSION = \"0.1.0\" abstract struct Command include Clip :: Mapper Clip . add_commands ({ \"hello\" => HelloCommand }) end struct HelloCommand < Command include Clip :: Mapper end def self . run begin command = Command . parse rescue ex : Clip :: MissingCommand pp ex rescue ex : Clip :: UnknownCommand pp! ex . command end end end Myapplication . run $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication # <Clip::MissingCommand:Error: you need to provide a command.> $ ./bin/myapplication goodbye ex.command # => \"goodbye\"","title":"Errors"},{"location":"user%20guide/errors/#errors","text":"When calling #parse you should always rescue errors, unless you want your application to crash in a bad way. The method can raises 3 different errors. Those errors have two common properties: they inherit from Clip::Error their message is preformatted and can be shown directly to the user The first property means you can rescue only Clip::Errors , and the second one means you can do puts ex or ex.to_s (where ex is the rescued exception) and you will have a nice message. Note Clip does not provide any i18n support for now, so all messages are in english.","title":"Errors"},{"location":"user%20guide/errors/#parsing-error","text":"If the parsing of options and arguments failed, a Clip::ParsingError exception is raised. The exception's message is already a ready-to-use message that you can present to the user, but the exception also provides a way to know what happens exactly.","title":"Parsing error"},{"location":"user%20guide/errors/#options-parsing-error","text":"The errors related to options parsing are accessible with Clip::ParsingError#options . It returns a Hash(String, Clip::Errors) The key is the name of the option which triggered the error. If the option was present in the user input, the name used will be kept. If not, there are two cases: either the option has no names specified with the Clip::Option annotation and the default one is used, or the first name in the annotation is used. The possible errors are: Clip::Errors::InvalidValue : the value provided for the option is invalid. It could be triggered when integers or floats are expected. Clip::Errors::MissingValue : a value must be provided for the option but there is no value. Clip::Errors::Required : the option is required but is not provided. Clip::Errors::Unknown : the provided option is unknown.","title":"Options parsing error"},{"location":"user%20guide/errors/#arguments-parsing-error","text":"In the same way, errors related to arguments parsing are accessible with Clip::ParsingError#arguments . It returns a Hash(String, Clip::Errors) . The key is the name of the argument. The possible errors are: Clip::Errors::InvalidValue : the value provided for the argument is invalid. It could be triggered when integers or floats are expected. Clip::Errors::Required : the argument is required but is not provided. Excess arguments are ignored, hence you will never get an Unknown error.","title":"Arguments parsing error"},{"location":"user%20guide/errors/#example","text":"require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Option ( \"-r\" , \"--repeat\" ) ] getter repeat = 1 @[ Clip::Option ] getter yell : Bool getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: ParsingError pp! ex . options , ex . arguments end end end Myapplication . run $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --repeat ex.options # => {\"--yell\" => Required, \"--repeat\" => MissingValue} ex.arguments # => {\"name\" => Required} $ ./bin/myapplication --yell -r yes --name Alice Barbara ex.options # => {\"-r\" => InvalidValue, \"--name\" => Unknown} ex.arguments # => {}","title":"Example"},{"location":"user%20guide/errors/#nested-commands-error","text":"When using nested commands, two exceptions can be raised: Clip::MissingCommand : a nested command is expected but none is provided. Clip::UnknownCommand : the provided nested command is unknown. The command is accessible with Clip::UnknownCommand.command . require \"clip\" module Myapplication VERSION = \"0.1.0\" abstract struct Command include Clip :: Mapper Clip . add_commands ({ \"hello\" => HelloCommand }) end struct HelloCommand < Command include Clip :: Mapper end def self . run begin command = Command . parse rescue ex : Clip :: MissingCommand pp ex rescue ex : Clip :: UnknownCommand pp! ex . command end end end Myapplication . run $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication # <Clip::MissingCommand:Error: you need to provide a command.> $ ./bin/myapplication goodbye ex.command # => \"goodbye\"","title":"Nested commands error"},{"location":"user%20guide/first_steps/","text":"First steps \u00b6 Let's do a hello world like app. We change src/myapplication.cr to: require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name ) end end def self . hello ( name ) puts \"Hello #{ name } \" end end Myapplication . run We can build and run the app, it works as expected: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --help Show this message and exit. $ ./bin/myapplication Alice Hello Alice $ ./bin/myapplication Error: argument is required: NAME We will now look at every block of code. Mapping a type \u00b6 struct Command include Clip :: Mapper getter name : String end Clip works by including Clip::Mapper inside a user defined type, a class or a struct. When the module is included, a macro is executed and generates a constructor, the method #parse we used, and the help message. It does that by analysing the type's attributes to find options and arguments. We say it maps the type definition to the expected CLI parameters, hence the name \"Mapper\". The advantage is that we have a classic type definition, which guarantees us type validation at compilation time. Here Clip detected that we need one argument named NAME . Tip A class is allocated on the heap and passed by reference while a struct is allocated on the stack and passed by value. Hence structs are better suited for read only object. In this tutorial we will only use structs as we will never need to edit the object, but you can use classes as well. Parsing the user input \u00b6 begin command = Command . parse rescue ex : Clip :: Error puts ex return end As said before, the macro creates a #parse method. It accepts an array of strings, and defaults to ARGV . This method acts as a constructor. It tries to parse the input, and on success it returns a new object. But there are two other cases: on user input failure, it raises an error if the user uses the special flag --help , it returns a special Help object Catching user input error \u00b6 begin command = Command . parse rescue ex : Clip :: Error puts ex return end If the user makes a mistake, by example if he uses an option not defined or does not set a required argument, the #parse method raises an exception. The exceptions raised by #parse have two properties: they always inherits from Clip::Error their message is a preformatted error message This means that you can just rescue Clip::Error and puts the rescued exception to show the user a nice error message, as we just did. We will see later in this tutorial exactly what exceptions can be raised and how you can use them to format your own error messages. The help case \u00b6 if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name ) end The help option is a special case that needs a special treatment. When the user set --help , he does not expect to get an error because NAME is required and was not provided. But NAME is indeed required, and we cannot return a Command instance as the Crystal compiler will complain that @name was not initialized (and we don't want to initialize it with a random or arbitrary value). The choice made by Clip is to return a instance of the special type Command::Help . This type was generated when including the Clip::Mapper module and has two properties: it inherits from Clip::Mapper::Help it provide a method #help that returns the generated help message That why we do this first check using #is_a? : to print the help if requested by the user. Accessing the user input \u00b6 if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name ) end Finally we use the user input wich was filled into the object attributes. As we are in the else clause of if command.is_a?(Clip::Mapper::Help) the compiler knows that our object is an instance of Command , and we can use its attribute name . Options, arguments and parameters \u00b6 So far we used those tree words. We said that NAME is an argument, that --help is an option, and we mentioned CLI parameters . But what are they? Note All that follows is just conventions. They are more often than not respected, but some command may have different conventions, like tar which accepts options without hypens. CLI Parameters \u00b6 A CLI parameter or just parameter is anything given after the executable's name when executing a command. So in the command ls -lh /tmp , the parameters are -lh and /tmp . Options \u00b6 An option is a specific type of parameter that must be named. It can have a value or not, it can be long or short, and if short it can be concatenated . $ somecommand --name = Alice -lg --file somefile In this fictitious command there are 4 options: --name , with a value Alice -l , without value -g , without value --file , with a value somefile Arguments \u00b6 An argument is a specific type of parameter that have a value but is not be named. In our command myapplication the usage says: ./bin/myapplication [OPTIONS] NAME . NAME is an argument, so we don't write ./bin/myapplication --name Alice but instead ./bin/myapplication Alice .","title":"First steps"},{"location":"user%20guide/first_steps/#first-steps","text":"Let's do a hello world like app. We change src/myapplication.cr to: require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name ) end end def self . hello ( name ) puts \"Hello #{ name } \" end end Myapplication . run We can build and run the app, it works as expected: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --help Show this message and exit. $ ./bin/myapplication Alice Hello Alice $ ./bin/myapplication Error: argument is required: NAME We will now look at every block of code.","title":"First steps"},{"location":"user%20guide/first_steps/#mapping-a-type","text":"struct Command include Clip :: Mapper getter name : String end Clip works by including Clip::Mapper inside a user defined type, a class or a struct. When the module is included, a macro is executed and generates a constructor, the method #parse we used, and the help message. It does that by analysing the type's attributes to find options and arguments. We say it maps the type definition to the expected CLI parameters, hence the name \"Mapper\". The advantage is that we have a classic type definition, which guarantees us type validation at compilation time. Here Clip detected that we need one argument named NAME . Tip A class is allocated on the heap and passed by reference while a struct is allocated on the stack and passed by value. Hence structs are better suited for read only object. In this tutorial we will only use structs as we will never need to edit the object, but you can use classes as well.","title":"Mapping a type"},{"location":"user%20guide/first_steps/#parsing-the-user-input","text":"begin command = Command . parse rescue ex : Clip :: Error puts ex return end As said before, the macro creates a #parse method. It accepts an array of strings, and defaults to ARGV . This method acts as a constructor. It tries to parse the input, and on success it returns a new object. But there are two other cases: on user input failure, it raises an error if the user uses the special flag --help , it returns a special Help object","title":"Parsing the user input"},{"location":"user%20guide/first_steps/#catching-user-input-error","text":"begin command = Command . parse rescue ex : Clip :: Error puts ex return end If the user makes a mistake, by example if he uses an option not defined or does not set a required argument, the #parse method raises an exception. The exceptions raised by #parse have two properties: they always inherits from Clip::Error their message is a preformatted error message This means that you can just rescue Clip::Error and puts the rescued exception to show the user a nice error message, as we just did. We will see later in this tutorial exactly what exceptions can be raised and how you can use them to format your own error messages.","title":"Catching user input error"},{"location":"user%20guide/first_steps/#the-help-case","text":"if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name ) end The help option is a special case that needs a special treatment. When the user set --help , he does not expect to get an error because NAME is required and was not provided. But NAME is indeed required, and we cannot return a Command instance as the Crystal compiler will complain that @name was not initialized (and we don't want to initialize it with a random or arbitrary value). The choice made by Clip is to return a instance of the special type Command::Help . This type was generated when including the Clip::Mapper module and has two properties: it inherits from Clip::Mapper::Help it provide a method #help that returns the generated help message That why we do this first check using #is_a? : to print the help if requested by the user.","title":"The help case"},{"location":"user%20guide/first_steps/#accessing-the-user-input","text":"if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name ) end Finally we use the user input wich was filled into the object attributes. As we are in the else clause of if command.is_a?(Clip::Mapper::Help) the compiler knows that our object is an instance of Command , and we can use its attribute name .","title":"Accessing the user input"},{"location":"user%20guide/first_steps/#options-arguments-and-parameters","text":"So far we used those tree words. We said that NAME is an argument, that --help is an option, and we mentioned CLI parameters . But what are they? Note All that follows is just conventions. They are more often than not respected, but some command may have different conventions, like tar which accepts options without hypens.","title":"Options, arguments and parameters"},{"location":"user%20guide/first_steps/#cli-parameters","text":"A CLI parameter or just parameter is anything given after the executable's name when executing a command. So in the command ls -lh /tmp , the parameters are -lh and /tmp .","title":"CLI Parameters"},{"location":"user%20guide/first_steps/#options","text":"An option is a specific type of parameter that must be named. It can have a value or not, it can be long or short, and if short it can be concatenated . $ somecommand --name = Alice -lg --file somefile In this fictitious command there are 4 options: --name , with a value Alice -l , without value -g , without value --file , with a value somefile","title":"Options"},{"location":"user%20guide/first_steps/#arguments","text":"An argument is a specific type of parameter that have a value but is not be named. In our command myapplication the usage says: ./bin/myapplication [OPTIONS] NAME . NAME is an argument, so we don't write ./bin/myapplication --name Alice but instead ./bin/myapplication Alice .","title":"Arguments"},{"location":"user%20guide/help/","text":"Help \u00b6 Clip generates an help message for every commands, respecting the known conventions used since decades by many CLI applications, as we already seen it in the previous sections. The #help method \u00b6 When the module Clip::Mapper is included, three methods are generated: #initialize #parse and #help The #help method returns the help message: require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper getter repeat = 1 getter name : String end def self . run puts Command . help end end Myapplication . run $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --repeat INTEGER [default: 1] --help Show this message and exit. This method accepts one parameter: the program's name. The default value is PROGRAM_NAME . You can set it to nil , which is useful for non CLI appliaction . require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper getter repeat = 1 getter name : String end def self . run puts Command . help ( \"tutorialapp\" ) puts \"---\" puts Command . help ( nil ) end end Myapplication . run $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication Usage: tutorialapp [OPTIONS] NAME Arguments: NAME [required] Options: --repeat INTEGER [default: 1] --help Show this message and exit. --- Usage: [OPTIONS] NAME Arguments: NAME [required] Options: --repeat INTEGER [default: 1] --help Show this message and exit. The Help object \u00b6 The #help method is fine, but it does not work with nested commands. As it is called on the command itself, it has no context about the command being nested or not. See this example: require \"clip\" module Myapplication VERSION = \"0.1.0\" abstract struct Command include Clip :: Mapper Clip . add_commands ({ \"hello\" => HelloCommand }) getter repeat = 1 end struct HelloCommand < Command include Clip :: Mapper getter name : String end def self . run puts HelloCommand . help end end Myapplication . run $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --repeat INTEGER [default: 1] --help Show this message and exit. Here the usage shown is wrong. If you try this to excute ./bin/myapplication Alice it will actually complains that Alice is an unknown command. Futhermore, you probably want to show the help when the user ask for it. And you can try, but setting an --help option yourself would require to define all other options and arguments as optional, as you probably don't want that ./bin/myapplication --help complains about NAME not being set. And setting everything optional defeat the purpose of having a library validating required options an arguments for you. So to fix all that Clip provides a special mechanism for the help. We have used it already. When using #parse , Clip checks before the parsing if the user input contains --help (or help if the command has nested commands). If it is the case, it returns a special object Help . The parsing is not done, so missing required options or arguments don't raise an error. The Help object has two properties: it inherits from Clip::Mapper::Help it exposes a method #help The first property is useful when using nested commands. The Help type is generated for each command, so without this property you would have to check if the returned value from #parse is an Help object for each available command . Instead you can just check if the type is Clip::Mapper::Help . The second property is also useful when using nested commands. Help#help behaves like the #help method generated on your command, excepts it has context about nested commands . Let's fix our previous example with a nested command: require \"clip\" module Myapplication VERSION = \"0.1.0\" abstract struct Command include Clip :: Mapper Clip . add_commands ({ \"hello\" => HelloCommand }) getter repeat = 1 end struct HelloCommand < Command include Clip :: Mapper getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) # command is actually an HelloCommand::Help instance puts command . help end end end Myapplication . run The help is now correct: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication hello --help Usage: ./bin/myapplication hello [OPTIONS] NAME Arguments: NAME [required] Options: --repeat INTEGER [default: 1] --help Show this message and exit.","title":"Help"},{"location":"user%20guide/help/#help","text":"Clip generates an help message for every commands, respecting the known conventions used since decades by many CLI applications, as we already seen it in the previous sections.","title":"Help"},{"location":"user%20guide/help/#the-help-method","text":"When the module Clip::Mapper is included, three methods are generated: #initialize #parse and #help The #help method returns the help message: require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper getter repeat = 1 getter name : String end def self . run puts Command . help end end Myapplication . run $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --repeat INTEGER [default: 1] --help Show this message and exit. This method accepts one parameter: the program's name. The default value is PROGRAM_NAME . You can set it to nil , which is useful for non CLI appliaction . require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper getter repeat = 1 getter name : String end def self . run puts Command . help ( \"tutorialapp\" ) puts \"---\" puts Command . help ( nil ) end end Myapplication . run $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication Usage: tutorialapp [OPTIONS] NAME Arguments: NAME [required] Options: --repeat INTEGER [default: 1] --help Show this message and exit. --- Usage: [OPTIONS] NAME Arguments: NAME [required] Options: --repeat INTEGER [default: 1] --help Show this message and exit.","title":"The #help method"},{"location":"user%20guide/help/#the-help-object","text":"The #help method is fine, but it does not work with nested commands. As it is called on the command itself, it has no context about the command being nested or not. See this example: require \"clip\" module Myapplication VERSION = \"0.1.0\" abstract struct Command include Clip :: Mapper Clip . add_commands ({ \"hello\" => HelloCommand }) getter repeat = 1 end struct HelloCommand < Command include Clip :: Mapper getter name : String end def self . run puts HelloCommand . help end end Myapplication . run $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --repeat INTEGER [default: 1] --help Show this message and exit. Here the usage shown is wrong. If you try this to excute ./bin/myapplication Alice it will actually complains that Alice is an unknown command. Futhermore, you probably want to show the help when the user ask for it. And you can try, but setting an --help option yourself would require to define all other options and arguments as optional, as you probably don't want that ./bin/myapplication --help complains about NAME not being set. And setting everything optional defeat the purpose of having a library validating required options an arguments for you. So to fix all that Clip provides a special mechanism for the help. We have used it already. When using #parse , Clip checks before the parsing if the user input contains --help (or help if the command has nested commands). If it is the case, it returns a special object Help . The parsing is not done, so missing required options or arguments don't raise an error. The Help object has two properties: it inherits from Clip::Mapper::Help it exposes a method #help The first property is useful when using nested commands. The Help type is generated for each command, so without this property you would have to check if the returned value from #parse is an Help object for each available command . Instead you can just check if the type is Clip::Mapper::Help . The second property is also useful when using nested commands. Help#help behaves like the #help method generated on your command, excepts it has context about nested commands . Let's fix our previous example with a nested command: require \"clip\" module Myapplication VERSION = \"0.1.0\" abstract struct Command include Clip :: Mapper Clip . add_commands ({ \"hello\" => HelloCommand }) getter repeat = 1 end struct HelloCommand < Command include Clip :: Mapper getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) # command is actually an HelloCommand::Help instance puts command . help end end end Myapplication . run The help is now correct: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication hello --help Usage: ./bin/myapplication hello [OPTIONS] NAME Arguments: NAME [required] Options: --repeat INTEGER [default: 1] --help Show this message and exit.","title":"The Help object"},{"location":"user%20guide/non_cli_app/","text":"Non CLI applications \u00b6 In this whole documentation we used a CLI application to demonstrate the capabilities of Clip . But one goal of Clip is to work as well for a CLI application than for an application which interacts with users in a text way and want to use options, arguments or commands. Example of such applications are REPL or text bots (like IRC bots). Let's build a very simple REPL : module Myapplication VERSION = \"0.1.0\" def self . run loop do print \"> \" case gets when \"hello\" self . hello when \"exit\" return else puts \"Unknown command.\" end end end def self . hello puts \"Hello, world!\" end end Myapplication . run It does not do much, but it does something: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication > help Unknown command. > hello Hello, world! > exit Now we would like to let the user specify the person to greet. We could try to parse the input when it starts with \"hello\", and accept one argument. Then we may want to add another feature that could be enabled but would be disabled by default, something like\u2026 an option. And then we will probably want to add some others commands, and we will need an help command so the user could known which commands are available and how to use them. You have probably guessed it yet: we want to interact with our REPL like we would do with a CLI application. So why writing all this mechanism by ourself? Unlike most of the CLI application libraries, Clip was built from the begining with this use case in mind. That's why Clip never prints anything by itself. You are in control, because your output may not be STDOUT but instead an IRC channel or anything else. Let's use Clip to build a nicer REPL with all that we learned: require \"process\" require \"clip\" module Myapplication VERSION = \"0.1.0\" @[ Clip::Doc ( \"Greet a person.\" ) ] abstract struct Command include Clip :: Mapper Clip . add_commands ({ \"hello\" => HelloCommand , \"goodbye\" => GoodbyeCommand , \"exit\" => ExitCommand , }) end abstract struct GreetCommand < Command @[ Clip::Doc ( \"The name of the person to greet.\" ) ] getter name : String end @[ Clip::Doc ( \"Say hello to someone.\" ) ] struct HelloCommand < GreetCommand include Clip :: Mapper @[ Clip::Doc ( \"Repeat the message many times.\" ) ] getter repeat = 1 end @[ Clip::Doc ( \"Say goodbye to someone.\" ) ] struct GoodbyeCommand < GreetCommand include Clip :: Mapper @[ Clip::Option ( \"-y\" , \"--yell\" ) ] @[ Clip::Doc ( \"Activate YELLING.\" ) ] getter yell : Bool? = nil end @[ Clip::Doc ( \"Exit the program.\" ) ] struct ExitCommand < Command include Clip :: Mapper end def self . run loop do print \"> \" if input = gets begin command = Command . parse ( input ) rescue ex : Clip :: Error puts ex next end case command when Clip :: Mapper :: Help puts command . help ( nil ) when HelloCommand hello ( command . name , command . repeat ) when GoodbyeCommand goodbye ( command . name , command . yell ) when ExitCommand return end else # we get here if the user types ^D puts return end end end def self . hello ( name , repeat ) repeat . times { puts \"Hello, #{ name } !\" } end def self . goodbye ( name , yell ) msg = \"Goodbye, #{ name } !\" if yell puts msg . upcase else puts msg end end end Myapplication . run Tip We could parse the input string using Process.parse_arguments , but the #parse method provides a shortcut and accepts a string. Internally it uses the exact same method from the Process class. Now we have options and arguments support, beautiful help messages, and error handling! $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication > help Usage: COMMAND [ARGS]... Greet a person. Commands: hello Say hello to someone. goodbye Say goodbye to someone. exit Exit the program. help Show this message and exit. > hello --help Usage: hello [OPTIONS] NAME Say hello to someone. Arguments: NAME The name of the person to greet. [required] Options: --repeat INTEGER Repeat the message many times. [default: 1] --help Show this message and exit. > goodbye --help Usage: goodbye [OPTIONS] NAME Say goodbye to someone. Arguments: NAME The name of the person to greet. [required] Options: -y, --yell Activate YELLING. --help Show this message and exit. > hello --repeat 2 Alice Hello, Alice! Hello, Alice! > goodbye -y Alice GOODBYE, ALICE! > hello -y Alice Error: no such option: -y > goodbye Error: argument is required: NAME > exit $","title":"Non CLI applications"},{"location":"user%20guide/non_cli_app/#non-cli-applications","text":"In this whole documentation we used a CLI application to demonstrate the capabilities of Clip . But one goal of Clip is to work as well for a CLI application than for an application which interacts with users in a text way and want to use options, arguments or commands. Example of such applications are REPL or text bots (like IRC bots). Let's build a very simple REPL : module Myapplication VERSION = \"0.1.0\" def self . run loop do print \"> \" case gets when \"hello\" self . hello when \"exit\" return else puts \"Unknown command.\" end end end def self . hello puts \"Hello, world!\" end end Myapplication . run It does not do much, but it does something: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication > help Unknown command. > hello Hello, world! > exit Now we would like to let the user specify the person to greet. We could try to parse the input when it starts with \"hello\", and accept one argument. Then we may want to add another feature that could be enabled but would be disabled by default, something like\u2026 an option. And then we will probably want to add some others commands, and we will need an help command so the user could known which commands are available and how to use them. You have probably guessed it yet: we want to interact with our REPL like we would do with a CLI application. So why writing all this mechanism by ourself? Unlike most of the CLI application libraries, Clip was built from the begining with this use case in mind. That's why Clip never prints anything by itself. You are in control, because your output may not be STDOUT but instead an IRC channel or anything else. Let's use Clip to build a nicer REPL with all that we learned: require \"process\" require \"clip\" module Myapplication VERSION = \"0.1.0\" @[ Clip::Doc ( \"Greet a person.\" ) ] abstract struct Command include Clip :: Mapper Clip . add_commands ({ \"hello\" => HelloCommand , \"goodbye\" => GoodbyeCommand , \"exit\" => ExitCommand , }) end abstract struct GreetCommand < Command @[ Clip::Doc ( \"The name of the person to greet.\" ) ] getter name : String end @[ Clip::Doc ( \"Say hello to someone.\" ) ] struct HelloCommand < GreetCommand include Clip :: Mapper @[ Clip::Doc ( \"Repeat the message many times.\" ) ] getter repeat = 1 end @[ Clip::Doc ( \"Say goodbye to someone.\" ) ] struct GoodbyeCommand < GreetCommand include Clip :: Mapper @[ Clip::Option ( \"-y\" , \"--yell\" ) ] @[ Clip::Doc ( \"Activate YELLING.\" ) ] getter yell : Bool? = nil end @[ Clip::Doc ( \"Exit the program.\" ) ] struct ExitCommand < Command include Clip :: Mapper end def self . run loop do print \"> \" if input = gets begin command = Command . parse ( input ) rescue ex : Clip :: Error puts ex next end case command when Clip :: Mapper :: Help puts command . help ( nil ) when HelloCommand hello ( command . name , command . repeat ) when GoodbyeCommand goodbye ( command . name , command . yell ) when ExitCommand return end else # we get here if the user types ^D puts return end end end def self . hello ( name , repeat ) repeat . times { puts \"Hello, #{ name } !\" } end def self . goodbye ( name , yell ) msg = \"Goodbye, #{ name } !\" if yell puts msg . upcase else puts msg end end end Myapplication . run Tip We could parse the input string using Process.parse_arguments , but the #parse method provides a shortcut and accepts a string. Internally it uses the exact same method from the Process class. Now we have options and arguments support, beautiful help messages, and error handling! $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication > help Usage: COMMAND [ARGS]... Greet a person. Commands: hello Say hello to someone. goodbye Say goodbye to someone. exit Exit the program. help Show this message and exit. > hello --help Usage: hello [OPTIONS] NAME Say hello to someone. Arguments: NAME The name of the person to greet. [required] Options: --repeat INTEGER Repeat the message many times. [default: 1] --help Show this message and exit. > goodbye --help Usage: goodbye [OPTIONS] NAME Say goodbye to someone. Arguments: NAME The name of the person to greet. [required] Options: -y, --yell Activate YELLING. --help Show this message and exit. > hello --repeat 2 Alice Hello, Alice! Hello, Alice! > goodbye -y Alice GOODBYE, ALICE! > hello -y Alice Error: no such option: -y > goodbye Error: argument is required: NAME > exit $","title":"Non CLI applications"},{"location":"user%20guide/setup/","text":"Setup \u00b6 This tutorial will cover step by step all the features of Clip . We will build a project together to explore them. You need a working Crystal environment. First, we create a new project: $ crystal init app myapplication create /home/erdnaxeli/bacasable/myapplication/.gitignore create /home/erdnaxeli/bacasable/myapplication/.editorconfig create /home/erdnaxeli/bacasable/myapplication/LICENSE create /home/erdnaxeli/bacasable/myapplication/README.md create /home/erdnaxeli/bacasable/myapplication/.travis.yml create /home/erdnaxeli/bacasable/myapplication/shard.yml create /home/erdnaxeli/bacasable/myapplication/src/myapplication.cr create /home/erdnaxeli/bacasable/myapplication/spec/spec_helper.cr create /home/erdnaxeli/bacasable/myapplication/spec/myapplication_spec.cr Initialized empty Git repository in /home/erdnaxeli/bacasable/myapplication/.git/ Then we add Clip as a dependency in shards.yml : dependencies : clip : github : erdnaxeli/clip In a real project you should add a constraint on the version, but we will skip it here. You can see the latest version in the header of this documentation or on the releases page . We can now build the app and run it: $ shards build Resolving dependencies Fetching https://github.com/erdnaxeli/clip.git Installing clip (0.2.2) Writing shard.lock Building: myapplication $ ./bin/myapplication $ In the next step we will write a simple application.","title":"Setup"},{"location":"user%20guide/setup/#setup","text":"This tutorial will cover step by step all the features of Clip . We will build a project together to explore them. You need a working Crystal environment. First, we create a new project: $ crystal init app myapplication create /home/erdnaxeli/bacasable/myapplication/.gitignore create /home/erdnaxeli/bacasable/myapplication/.editorconfig create /home/erdnaxeli/bacasable/myapplication/LICENSE create /home/erdnaxeli/bacasable/myapplication/README.md create /home/erdnaxeli/bacasable/myapplication/.travis.yml create /home/erdnaxeli/bacasable/myapplication/shard.yml create /home/erdnaxeli/bacasable/myapplication/src/myapplication.cr create /home/erdnaxeli/bacasable/myapplication/spec/spec_helper.cr create /home/erdnaxeli/bacasable/myapplication/spec/myapplication_spec.cr Initialized empty Git repository in /home/erdnaxeli/bacasable/myapplication/.git/ Then we add Clip as a dependency in shards.yml : dependencies : clip : github : erdnaxeli/clip In a real project you should add a constraint on the version, but we will skip it here. You can see the latest version in the header of this documentation or on the releases page . We can now build the app and run it: $ shards build Resolving dependencies Fetching https://github.com/erdnaxeli/clip.git Installing clip (0.2.2) Writing shard.lock Building: myapplication $ ./bin/myapplication $ In the next step we will write a simple application.","title":"Setup"},{"location":"user%20guide/arguments/multiple/","text":"Multiple arguments \u00b6 So far we only used one argument, but it is not uncommon for a command to support multiple arguments. To do that with Clip we just have to define other attributes: require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper getter repeat : Int32 getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) repeat . time { puts \"Hello #{ name } \" } end end Myapplication . run Our command has now two arguments: NAME and REPEAT . $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME REPEAT Arguments: NAME [required] REPEAT [required] Options: --help Show this message and exit. $ ./bin/myapplication 2 Alice Hello Alice Hello Alice Arguments ordering \u00b6 You may have noticed something strange in the previous example. The usage says \"NAME REPEAT\" but I wrote \"2 Alice\", so \"REPEAT NAME\". Unfortunately, this behavior comes from the Crystal compiler itself. When we include Clip::Mapper , two macros are run to generate the parser and the help message. Those macros rely on TypeNode#instance_vars to get all the type's attributes. Sadly, this method does not always return the attributes as they were ordered in the type declaration. Even sadder, multiple calls can return attributes in a different order. With our example the parser saw repeat and then name , but the help saw name and then repeat . That's why Clip provides a way to ensure the arguments ordering. It is done with the annotation Clip::Argument , with a named parameter idx : require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Argument ( idx : 1 ) ] getter repeat : Int32 @[ Clip::Argument ( idx : 2 ) ] getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) repeat . time { puts \"Hello #{ name } \" } end end Myapplication . run The arguments are now correctly ordered both in the help message and in the parser: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] REPEAT NAME Arguments: REPEAT [required] NAME [required] Options: --help Show this message and exit. $ ./bin/myapplication 1 Alice Hello Alice Arguments consuming order \u00b6 A little note about how the argument are consummed from the user input. Let's take the following command definition: Usage: ./bin/myapplication [OPTIONS] REPEAT NAME This command has two required arguments. Clip always consumes arguments from left to right . So if the user input is ./bin/myapplication 2 Alice , Clip consumes 2 and uses it as the value for REPEAT , then it consumes Alice and uses it as the value for NAME . So far so good. But what if we make REPEAT an optional argument? The command definition now looks like this: Usage: ./bin/myapplication [OPTIONS] [REPEAT] NAME When we give both arguments, Clip maps them both, and everything is ok. But if we give only one argument, Clip still maps it with REPEAT , as it consumes arguments from left to right. Then it finds no value for NAME and raises an error: require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Argument ( idx : 1 ) ] getter repeat = 1 @[ Clip::Argument ( idx : 2 ) ] getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) repeat . times { puts \"Hello #{ name } \" } end end Myapplication . run $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] [REPEAT] NAME Arguments: REPEAT [default: 1] NAME [required] Options: --help Show this message and exit. $ ./bin/myapplication 2 Alice Hello Alice Hello Alice $ ./bin/myapplication Alice Error: argument's value is invalid: REPEAT argument is required: NAME Let's make NAME optional instead: require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Argument ( idx : 1 ) ] getter repeat : Int32 @[ Clip::Argument ( idx : 2 ) ] getter name = \"Barbara\" end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) repeat . times { puts \"Hello #{ name } \" } end end Myapplication . run If we give only one argument Clip maps it to REPEAT , and as NAME is optional no error is raised: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] REPEAT [NAME] Arguments: REPEAT [required] NAME [default: Barbara] Options: --help Show this message and exit. $ ./bin/myapplication 2 Alice Hello Alice Hello Alice $ ./bin/myapplication 1 Hello Barbara To resume: you can use multiple arguments arguments are consumed from left to right hence optional arguments must be the last ones Note This is fully dependant on the current implementation of Clip and you may find other libraries without this constraint.","title":"Multiple arguments"},{"location":"user%20guide/arguments/multiple/#multiple-arguments","text":"So far we only used one argument, but it is not uncommon for a command to support multiple arguments. To do that with Clip we just have to define other attributes: require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper getter repeat : Int32 getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) repeat . time { puts \"Hello #{ name } \" } end end Myapplication . run Our command has now two arguments: NAME and REPEAT . $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME REPEAT Arguments: NAME [required] REPEAT [required] Options: --help Show this message and exit. $ ./bin/myapplication 2 Alice Hello Alice Hello Alice","title":"Multiple arguments"},{"location":"user%20guide/arguments/multiple/#arguments-ordering","text":"You may have noticed something strange in the previous example. The usage says \"NAME REPEAT\" but I wrote \"2 Alice\", so \"REPEAT NAME\". Unfortunately, this behavior comes from the Crystal compiler itself. When we include Clip::Mapper , two macros are run to generate the parser and the help message. Those macros rely on TypeNode#instance_vars to get all the type's attributes. Sadly, this method does not always return the attributes as they were ordered in the type declaration. Even sadder, multiple calls can return attributes in a different order. With our example the parser saw repeat and then name , but the help saw name and then repeat . That's why Clip provides a way to ensure the arguments ordering. It is done with the annotation Clip::Argument , with a named parameter idx : require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Argument ( idx : 1 ) ] getter repeat : Int32 @[ Clip::Argument ( idx : 2 ) ] getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) repeat . time { puts \"Hello #{ name } \" } end end Myapplication . run The arguments are now correctly ordered both in the help message and in the parser: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] REPEAT NAME Arguments: REPEAT [required] NAME [required] Options: --help Show this message and exit. $ ./bin/myapplication 1 Alice Hello Alice","title":"Arguments ordering"},{"location":"user%20guide/arguments/multiple/#arguments-consuming-order","text":"A little note about how the argument are consummed from the user input. Let's take the following command definition: Usage: ./bin/myapplication [OPTIONS] REPEAT NAME This command has two required arguments. Clip always consumes arguments from left to right . So if the user input is ./bin/myapplication 2 Alice , Clip consumes 2 and uses it as the value for REPEAT , then it consumes Alice and uses it as the value for NAME . So far so good. But what if we make REPEAT an optional argument? The command definition now looks like this: Usage: ./bin/myapplication [OPTIONS] [REPEAT] NAME When we give both arguments, Clip maps them both, and everything is ok. But if we give only one argument, Clip still maps it with REPEAT , as it consumes arguments from left to right. Then it finds no value for NAME and raises an error: require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Argument ( idx : 1 ) ] getter repeat = 1 @[ Clip::Argument ( idx : 2 ) ] getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) repeat . times { puts \"Hello #{ name } \" } end end Myapplication . run $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] [REPEAT] NAME Arguments: REPEAT [default: 1] NAME [required] Options: --help Show this message and exit. $ ./bin/myapplication 2 Alice Hello Alice Hello Alice $ ./bin/myapplication Alice Error: argument's value is invalid: REPEAT argument is required: NAME Let's make NAME optional instead: require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Argument ( idx : 1 ) ] getter repeat : Int32 @[ Clip::Argument ( idx : 2 ) ] getter name = \"Barbara\" end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) repeat . times { puts \"Hello #{ name } \" } end end Myapplication . run If we give only one argument Clip maps it to REPEAT , and as NAME is optional no error is raised: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] REPEAT [NAME] Arguments: REPEAT [required] NAME [default: Barbara] Options: --help Show this message and exit. $ ./bin/myapplication 2 Alice Hello Alice Hello Alice $ ./bin/myapplication 1 Hello Barbara To resume: you can use multiple arguments arguments are consumed from left to right hence optional arguments must be the last ones Note This is fully dependant on the current implementation of Clip and you may find other libraries without this constraint.","title":"Arguments consuming order"},{"location":"user%20guide/arguments/nilable/","text":"Nilable arguments \u00b6 Clip specifies in the help message if an argument is required or not, like this: NAME [required] or NAME [default: Barbara] If you don't want any message, you can declare the attribute's type as nilable and set the default value to nil : require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Argument ] getter name : String? = nil end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name ) end end def self . hello ( name ) if name .nil? puts \"Hello world!\" else puts \"Hello #{ name } \" end end end Myapplication . run Tip Crystal cannot infer anything from nil , hence we need to add back the type restriction. The help now looks like this: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] [NAME] Arguments: NAME Options: --help Show this message and exit. And it sets the correct default value: $ ./bin/myapplication Hello world! $ ./bin/myapplication Alice Hello Alice","title":"Nilable arguments"},{"location":"user%20guide/arguments/nilable/#nilable-arguments","text":"Clip specifies in the help message if an argument is required or not, like this: NAME [required] or NAME [default: Barbara] If you don't want any message, you can declare the attribute's type as nilable and set the default value to nil : require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Argument ] getter name : String? = nil end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name ) end end def self . hello ( name ) if name .nil? puts \"Hello world!\" else puts \"Hello #{ name } \" end end end Myapplication . run Tip Crystal cannot infer anything from nil , hence we need to add back the type restriction. The help now looks like this: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] [NAME] Arguments: NAME Options: --help Show this message and exit. And it sets the correct default value: $ ./bin/myapplication Hello world! $ ./bin/myapplication Alice Hello Alice","title":"Nilable arguments"},{"location":"user%20guide/arguments/optional/","text":"Optional arguments \u00b6 An argument can also be optional. Now that we know how to declare an explicit argument, all that we have to do is add a default value. Clip will know that the argument is now optional. require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Argument ] getter name = \"Barbara\" end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name ) end end def self . hello ( name : String ) puts \"Hello #{ name } \" end end Myapplication . run Tip As we added a default value, we can remove the type restriction. Crystal infers it from the default value. NAME is not required anymore: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] [NAME] Arguments: NAME [default: Barbara] Options: --help Show this message and exit. $ ./bin/myapplication Alice Hello Alice $ ./bin/myapplication Hello Barbara","title":"Optional arguments"},{"location":"user%20guide/arguments/optional/#optional-arguments","text":"An argument can also be optional. Now that we know how to declare an explicit argument, all that we have to do is add a default value. Clip will know that the argument is now optional. require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Argument ] getter name = \"Barbara\" end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name ) end end def self . hello ( name : String ) puts \"Hello #{ name } \" end end Myapplication . run Tip As we added a default value, we can remove the type restriction. Crystal infers it from the default value. NAME is not required anymore: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] [NAME] Arguments: NAME [default: Barbara] Options: --help Show this message and exit. $ ./bin/myapplication Alice Hello Alice $ ./bin/myapplication Hello Barbara","title":"Optional arguments"},{"location":"user%20guide/arguments/required/","text":"Required arguments \u00b6 Arguments are positional parameters . By default: an attribute is mapped to an argument if it has no default value and as it has no default value, it is required We will see in the next page how to make an argument optional. An implicit argument \u00b6 Let's take back our initial application: require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name ) end end def self . hello ( name : String ) puts \"Hello #{ name } \" end end Myapplication . run We defined an attribute name with a String type and no default value. Clip maps it to an argument, as we already saw. Let's enjoy it again :) $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --help Show this message and exit. $ ./bin/myapplication Alice Hello Alice $ ./bin/myapplication Error: argument is required: NAME An explicit argument \u00b6 Like options, we can also explicitly declare our attribute as an argument with the annotation Clip::Argument . require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Argument ] getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name ) end end def self . hello ( name : String ) puts \"Hello #{ name } \" end end Myapplication . run It still behaves the same: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --help Show this message and exit. $ ./bin/myapplication Alice Hello Alice $ ./bin/myapplication Error: argument is required: NAME","title":"Required arguments"},{"location":"user%20guide/arguments/required/#required-arguments","text":"Arguments are positional parameters . By default: an attribute is mapped to an argument if it has no default value and as it has no default value, it is required We will see in the next page how to make an argument optional.","title":"Required arguments"},{"location":"user%20guide/arguments/required/#an-implicit-argument","text":"Let's take back our initial application: require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name ) end end def self . hello ( name : String ) puts \"Hello #{ name } \" end end Myapplication . run We defined an attribute name with a String type and no default value. Clip maps it to an argument, as we already saw. Let's enjoy it again :) $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --help Show this message and exit. $ ./bin/myapplication Alice Hello Alice $ ./bin/myapplication Error: argument is required: NAME","title":"An implicit argument"},{"location":"user%20guide/arguments/required/#an-explicit-argument","text":"Like options, we can also explicitly declare our attribute as an argument with the annotation Clip::Argument . require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Argument ] getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name ) end end def self . hello ( name : String ) puts \"Hello #{ name } \" end end Myapplication . run It still behaves the same: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --help Show this message and exit. $ ./bin/myapplication Alice Hello Alice $ ./bin/myapplication Error: argument is required: NAME","title":"An explicit argument"},{"location":"user%20guide/arguments/types/","text":"Arguments types \u00b6 So far we used two types for an argument: String and String? . But like options you can use numeric types too. The supported types are: all subtypes of Int : Int32 , UInt32 , and all others all subtypes of Float : BigFloat , Float32 and Float64 String and all those types combined with Nil : Int32? , Float32? , String? , and so on. Bool is not supported. It can only be used with a flag. During the parsing, Clip tries to convert the string to the attribute's type. If any error happens, a Clip::ParsingError is raised (see the errors section for details). require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper getter name : Int32 end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name ) end end def self . hello ( name ) puts \"Hello #{ name } \" end end Myapplication . run $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --help Show this message and exit. $ ./bin/myapplication Alice Error: argument's value is invalid: NAME $ ./bin/myapplication 42 Hello 42","title":"Argument types"},{"location":"user%20guide/arguments/types/#arguments-types","text":"So far we used two types for an argument: String and String? . But like options you can use numeric types too. The supported types are: all subtypes of Int : Int32 , UInt32 , and all others all subtypes of Float : BigFloat , Float32 and Float64 String and all those types combined with Nil : Int32? , Float32? , String? , and so on. Bool is not supported. It can only be used with a flag. During the parsing, Clip tries to convert the string to the attribute's type. If any error happens, a Clip::ParsingError is raised (see the errors section for details). require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper getter name : Int32 end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name ) end end def self . hello ( name ) puts \"Hello #{ name } \" end end Myapplication . run $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --help Show this message and exit. $ ./bin/myapplication Alice Error: argument's value is invalid: NAME $ ./bin/myapplication 42 Hello 42","title":"Arguments types"},{"location":"user%20guide/options/flags/","text":"Flags \u00b6 A flag is a special option that has no value, at least from a user perspective. The flag actually does have a value, but it is a boolean. Common flags you may have encountered already are --verbose or --debug . They are usually used to enabled or disabled a feature. Default flag \u00b6 A flag is boolean option, so all we need to do is define an attribute with a Bool type. require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper getter yell = false getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . yell ) end end def self . hello ( name , yell ) if yell puts \"Hello #{ name } \" . upcase else puts \"Hello #{ name } \" end end end Myapplication . run Clip generate two options for each flag: one for a true value the other for the false value $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --yell / --no-yell [default: false] --help Show this message and exit. $ ./bin/myapplication Alice Hello Alice $ ./bin/myapplication --yell Alice HELLO ALICE $ ./bin/myapplication --no-yell Alice Hello Alice Required flag \u00b6 As any option, a flag can be required: require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Option ] getter yell : Bool getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . yell ) end end def self . hello ( name , yell ) if yell puts \"Hello #{ name } \" . upcase else puts \"Hello #{ name } \" end end end Myapplication . run No setting the flag is now an error: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --yell / --no-yell [required] --help Show this message and exit. $ ./bin/myapplication Alice Error: option is required: --yell $ ./bin/myapplication --yell Alice HELLO ALICE $ ./bin/myapplication --no-yell Alice Hello Alice Nilable flag \u00b6 A flag can also have a default value nil : require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper getter yell : Bool? = nil getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . yell ) end end def self . hello ( name , yell ) if yell puts \"Hello #{ name } \" . upcase else puts \"Hello #{ name } \" end end end Myapplication . run Tip As nil is a falsy value we don't have to write if !yell.nil? && yell . $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --yell / --no-yell --help Show this message and exit. $ ./bin/myapplication Alice Hello Alice $ ./bin/myapplication --yell Alice HELLO ALICE $ ./bin/myapplication --no-yell Alice Hello Alice","title":"Flags"},{"location":"user%20guide/options/flags/#flags","text":"A flag is a special option that has no value, at least from a user perspective. The flag actually does have a value, but it is a boolean. Common flags you may have encountered already are --verbose or --debug . They are usually used to enabled or disabled a feature.","title":"Flags"},{"location":"user%20guide/options/flags/#default-flag","text":"A flag is boolean option, so all we need to do is define an attribute with a Bool type. require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper getter yell = false getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . yell ) end end def self . hello ( name , yell ) if yell puts \"Hello #{ name } \" . upcase else puts \"Hello #{ name } \" end end end Myapplication . run Clip generate two options for each flag: one for a true value the other for the false value $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --yell / --no-yell [default: false] --help Show this message and exit. $ ./bin/myapplication Alice Hello Alice $ ./bin/myapplication --yell Alice HELLO ALICE $ ./bin/myapplication --no-yell Alice Hello Alice","title":"Default flag"},{"location":"user%20guide/options/flags/#required-flag","text":"As any option, a flag can be required: require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Option ] getter yell : Bool getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . yell ) end end def self . hello ( name , yell ) if yell puts \"Hello #{ name } \" . upcase else puts \"Hello #{ name } \" end end end Myapplication . run No setting the flag is now an error: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --yell / --no-yell [required] --help Show this message and exit. $ ./bin/myapplication Alice Error: option is required: --yell $ ./bin/myapplication --yell Alice HELLO ALICE $ ./bin/myapplication --no-yell Alice Hello Alice","title":"Required flag"},{"location":"user%20guide/options/flags/#nilable-flag","text":"A flag can also have a default value nil : require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper getter yell : Bool? = nil getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . yell ) end end def self . hello ( name , yell ) if yell puts \"Hello #{ name } \" . upcase else puts \"Hello #{ name } \" end end end Myapplication . run Tip As nil is a falsy value we don't have to write if !yell.nil? && yell . $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --yell / --no-yell --help Show this message and exit. $ ./bin/myapplication Alice Hello Alice $ ./bin/myapplication --yell Alice HELLO ALICE $ ./bin/myapplication --no-yell Alice Hello Alice","title":"Nilable flag"},{"location":"user%20guide/options/name/","text":"Option name \u00b6 By default Clip creates the option using the attribute as its name. The only change it does is substituting underscores with hyphen. But you can change the option's name, as we will see. Changing the option name \u00b6 To do that we use again the annotation Clip::Option . require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Option ( \"--times\" ) ] getter repeat = 1 getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) repeat . times { puts \"Hello #{ name } \" } end end Myapplication . run Clip uses the name given to the annotation instead of the attribute's name: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --times INTEGER [default: 1] --help Show this message and exit. $ ./bin/myapplication Alice Hello Alice $ ./bin/myapplication --times 2 Alice Hello Alice Hello Alice Short options \u00b6 Sometime typing the full option's name can be tedious. Many commands offer short aliases for common options. To define them, we still use the annotation Clip::Option . require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Option ( \"-t\" ) ] getter repeat = 1 getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) repeat . times { puts \"Hello #{ name } \" } end end Myapplication . run What you expect happens: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: -t INTEGER [default: 1] --help Show this message and exit. $ ./bin/myapplication Alice Hello Alice $ ./bin/myapplication -t 2 Alice Hello Alice Hello Alice You may have noticed that the long name is gone. Clip actually only uses the name from the annotation. If you want to use a short name and a long name, you have to specify both of them in the annotation: require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Option ( \"-t\" , \"--times\" ) ] getter repeat = 1 getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) repeat . times { puts \"Hello #{ name } \" } end end Myapplication . run Both options -t and --times are now supported: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: -t, --times INTEGER [default: 1] --help Show this message and exit. $ ./bin/myapplication -t 2 Alice Hello Alice Hello Alice $ ./bin/myapplication --times 2 Alice Hello Alice Hello Alice Flags \u00b6 You can use the same annotation to change the name of a flag, short or long. But if you do, Clip no longer generates the negative flag ( --no-yell in our previous example). The behavior to get a true or false value changes a little bit and depends on the attribute's default value. When the flag is set: if there is no default value, the attribute value will be true (and the flag will be required, so it is not very helpful) if the default value is false or nil , the value will be true if the default value is true , the value will be false Here is an example: require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Option ( \"-f\" , \"--feature\" ) ] getter feature1 = true @[ Clip::Option ( \"-g\" ) ] getter feature2 = false getter feature3 : Bool? = nil end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . feature1 , command . feature2 , command . feature3 ) end end def self . hello ( feature1 , feature2 , feature3 ) p! feature1 p! feature2 p! feature3 end end Myapplication . run $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] Options: --feature3 / --no-feature3 -f, --feature [default: true] -g [default: false] --help Show this message and exit. $ ./bin/myapplication feature1 # => true feature2 # => false feature3 # => nil $ ./bin/myapplication -f feature1 # => false feature2 # => false feature3 # => nil $ ./bin/myapplication --feature feature1 # => false feature2 # => false feature3 # => nil $ ./bin/myapplication -g feature1 # => true feature2 # => true feature3 # => nil $ ./bin/myapplication --feature3 feature1 # => true feature2 # => false feature3 # => true","title":"Option name"},{"location":"user%20guide/options/name/#option-name","text":"By default Clip creates the option using the attribute as its name. The only change it does is substituting underscores with hyphen. But you can change the option's name, as we will see.","title":"Option name"},{"location":"user%20guide/options/name/#changing-the-option-name","text":"To do that we use again the annotation Clip::Option . require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Option ( \"--times\" ) ] getter repeat = 1 getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) repeat . times { puts \"Hello #{ name } \" } end end Myapplication . run Clip uses the name given to the annotation instead of the attribute's name: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --times INTEGER [default: 1] --help Show this message and exit. $ ./bin/myapplication Alice Hello Alice $ ./bin/myapplication --times 2 Alice Hello Alice Hello Alice","title":"Changing the option name"},{"location":"user%20guide/options/name/#short-options","text":"Sometime typing the full option's name can be tedious. Many commands offer short aliases for common options. To define them, we still use the annotation Clip::Option . require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Option ( \"-t\" ) ] getter repeat = 1 getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) repeat . times { puts \"Hello #{ name } \" } end end Myapplication . run What you expect happens: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: -t INTEGER [default: 1] --help Show this message and exit. $ ./bin/myapplication Alice Hello Alice $ ./bin/myapplication -t 2 Alice Hello Alice Hello Alice You may have noticed that the long name is gone. Clip actually only uses the name from the annotation. If you want to use a short name and a long name, you have to specify both of them in the annotation: require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Option ( \"-t\" , \"--times\" ) ] getter repeat = 1 getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) repeat . times { puts \"Hello #{ name } \" } end end Myapplication . run Both options -t and --times are now supported: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: -t, --times INTEGER [default: 1] --help Show this message and exit. $ ./bin/myapplication -t 2 Alice Hello Alice Hello Alice $ ./bin/myapplication --times 2 Alice Hello Alice Hello Alice","title":"Short options"},{"location":"user%20guide/options/name/#flags","text":"You can use the same annotation to change the name of a flag, short or long. But if you do, Clip no longer generates the negative flag ( --no-yell in our previous example). The behavior to get a true or false value changes a little bit and depends on the attribute's default value. When the flag is set: if there is no default value, the attribute value will be true (and the flag will be required, so it is not very helpful) if the default value is false or nil , the value will be true if the default value is true , the value will be false Here is an example: require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Option ( \"-f\" , \"--feature\" ) ] getter feature1 = true @[ Clip::Option ( \"-g\" ) ] getter feature2 = false getter feature3 : Bool? = nil end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . feature1 , command . feature2 , command . feature3 ) end end def self . hello ( feature1 , feature2 , feature3 ) p! feature1 p! feature2 p! feature3 end end Myapplication . run $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] Options: --feature3 / --no-feature3 -f, --feature [default: true] -g [default: false] --help Show this message and exit. $ ./bin/myapplication feature1 # => true feature2 # => false feature3 # => nil $ ./bin/myapplication -f feature1 # => false feature2 # => false feature3 # => nil $ ./bin/myapplication --feature feature1 # => false feature2 # => false feature3 # => nil $ ./bin/myapplication -g feature1 # => true feature2 # => true feature3 # => nil $ ./bin/myapplication --feature3 feature1 # => true feature2 # => false feature3 # => true","title":"Flags"},{"location":"user%20guide/options/nilable/","text":"Nilable options \u00b6 You may have noticed that Clip adds in the help message if the option has a default value or is required. It looks like this: --repeat INTEGER [default: 1] or --repeat INTEGER [required] Sometimes you may not want those messages to be shown. Maybe you want the option to be optional and have a default value, but you don't want to expose this value to the user. We can do this by making the attribute's type nilable and set its default value nil : require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper getter repeat : Int32? = nil getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) if repeat .nil? puts \"Hello #{ name } \" else repeat . times { puts \"Hello #{ name } \" } end end end Myapplication . run Tip As our attribute does have a default value we don't have to explicitly add the Clip::Option annotation. Note command.repeat is now either an Int32 or a Nil value, so we can't directly call #times on it or the compiler will complain that this method is not defined for Nil . The help now looks like this: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --repeat INTEGER --help Show this message and exit. And the behavior is still the same: $ ./bin/myapplication Alice Hello Alice $ ./bin/myapplication --repeat 2 Alice Hello Alice Hello Alice Whether you choose to use a default nil value or not is up to you.","title":"Nilable options"},{"location":"user%20guide/options/nilable/#nilable-options","text":"You may have noticed that Clip adds in the help message if the option has a default value or is required. It looks like this: --repeat INTEGER [default: 1] or --repeat INTEGER [required] Sometimes you may not want those messages to be shown. Maybe you want the option to be optional and have a default value, but you don't want to expose this value to the user. We can do this by making the attribute's type nilable and set its default value nil : require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper getter repeat : Int32? = nil getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) if repeat .nil? puts \"Hello #{ name } \" else repeat . times { puts \"Hello #{ name } \" } end end end Myapplication . run Tip As our attribute does have a default value we don't have to explicitly add the Clip::Option annotation. Note command.repeat is now either an Int32 or a Nil value, so we can't directly call #times on it or the compiler will complain that this method is not defined for Nil . The help now looks like this: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --repeat INTEGER --help Show this message and exit. And the behavior is still the same: $ ./bin/myapplication Alice Hello Alice $ ./bin/myapplication --repeat 2 Alice Hello Alice Hello Alice Whether you choose to use a default nil value or not is up to you.","title":"Nilable options"},{"location":"user%20guide/options/optional/","text":"Optionnal options \u00b6 Options are named parameters . By default: an attribute is mapped to an option if it has a default value, and as it has a default value, it is optional We will see in the next page how this can be changed. An implicit option \u00b6 First, we add an option to our command: require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper getter repeat = 1 getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) repeat . times { puts \"Hello #{ name } \" } end end Myapplication . run Tip We don't have to specify the type of the attribute repeat , as the compiler will infer from the default value 1 that it is an Int32 . Let's try our option: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --repeat INTEGER [default: 1] --help Show this message and exit. $ ./bin/myapplication Alice Hello Alice $ ./bin/myapplication --repeat 2 Alice Hello Alice Hello Alice It all works as expected: the option --repeat is optional and has a default value. We can also use an = character to define the value: $ ./bin/myapplication --repeat = 2 Alice Hello Alice Hello Alice An explicit option \u00b6 An option can be explicitly declared with the annotation Clip::Option . require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Option ] getter repeat = 1 getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) repeat . times { puts \"Hello #{ name } \" } end end Myapplication . run Nothing has changed: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --repeat INTEGER [default: 1] --help Show this message and exit. $ ./bin/myapplication Alice Hello Alice $ ./bin/myapplication --repeat 2 Alice Hello Alice Hello Alice","title":"Optional options"},{"location":"user%20guide/options/optional/#optionnal-options","text":"Options are named parameters . By default: an attribute is mapped to an option if it has a default value, and as it has a default value, it is optional We will see in the next page how this can be changed.","title":"Optionnal options"},{"location":"user%20guide/options/optional/#an-implicit-option","text":"First, we add an option to our command: require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper getter repeat = 1 getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) repeat . times { puts \"Hello #{ name } \" } end end Myapplication . run Tip We don't have to specify the type of the attribute repeat , as the compiler will infer from the default value 1 that it is an Int32 . Let's try our option: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --repeat INTEGER [default: 1] --help Show this message and exit. $ ./bin/myapplication Alice Hello Alice $ ./bin/myapplication --repeat 2 Alice Hello Alice Hello Alice It all works as expected: the option --repeat is optional and has a default value. We can also use an = character to define the value: $ ./bin/myapplication --repeat = 2 Alice Hello Alice Hello Alice","title":"An implicit option"},{"location":"user%20guide/options/optional/#an-explicit-option","text":"An option can be explicitly declared with the annotation Clip::Option . require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Option ] getter repeat = 1 getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) repeat . times { puts \"Hello #{ name } \" } end end Myapplication . run Nothing has changed: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --repeat INTEGER [default: 1] --help Show this message and exit. $ ./bin/myapplication Alice Hello Alice $ ./bin/myapplication --repeat 2 Alice Hello Alice Hello Alice","title":"An explicit option"},{"location":"user%20guide/options/required/","text":"Required options \u00b6 An option can also be required. Now that we know how to declare an explicit option, all that we have to do is remove the default value. Clip will know that the option is now required. require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Option ] getter repeat : Int32 getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) repeat . times { puts \"Hello #{ name } \" } end end Myapplication . run Note Now that we removed the default value, we have to specify the type of the attribute repeat so the compiler (and Clip) knows it. It now complains if we don't provide the option: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --repeat INTEGER [required] --help Show this message and exit. $ ./bin/myapplication Alice Error: option is required: --repeat $ ./bin/myapplication --repeat 1 Alice Hello Alice $ ./bin/myapplication --repeat 2 Alice Hello Alice Hello Alice","title":"Required options"},{"location":"user%20guide/options/required/#required-options","text":"An option can also be required. Now that we know how to declare an explicit option, all that we have to do is remove the default value. Clip will know that the option is now required. require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper @[ Clip::Option ] getter repeat : Int32 getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) repeat . times { puts \"Hello #{ name } \" } end end Myapplication . run Note Now that we removed the default value, we have to specify the type of the attribute repeat so the compiler (and Clip) knows it. It now complains if we don't provide the option: $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --help Usage: ./bin/myapplication [OPTIONS] NAME Arguments: NAME [required] Options: --repeat INTEGER [required] --help Show this message and exit. $ ./bin/myapplication Alice Error: option is required: --repeat $ ./bin/myapplication --repeat 1 Alice Hello Alice $ ./bin/myapplication --repeat 2 Alice Hello Alice Hello Alice","title":"Required options"},{"location":"user%20guide/options/types/","text":"Options types \u00b6 So for we used two different types for options: integers and booleans. But you can use more! The supported types are: all subtypes of Int : Int32 , UInt32 , and all others all subtypes of Float : BigFloat , Float32 and Float64 Bool String and all those types combined with Nil : Int32? , Float32? , Bool? , String? , and so on. During the parsing, Clip tries to convert the string to the attribute's type. If any error happens, a Clip::ParsingError is raised (see the errors section for details). require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper getter repeat = 1 getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) repeat . times { puts \"Hello #{ name } \" } end end Myapplication . run $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --repeat two Alice Error: option's value is invalid: --repeat","title":"Option types"},{"location":"user%20guide/options/types/#options-types","text":"So for we used two different types for options: integers and booleans. But you can use more! The supported types are: all subtypes of Int : Int32 , UInt32 , and all others all subtypes of Float : BigFloat , Float32 and Float64 Bool String and all those types combined with Nil : Int32? , Float32? , Bool? , String? , and so on. During the parsing, Clip tries to convert the string to the attribute's type. If any error happens, a Clip::ParsingError is raised (see the errors section for details). require \"clip\" module Myapplication VERSION = \"0.1.0\" struct Command include Clip :: Mapper getter repeat = 1 getter name : String end def self . run begin command = Command . parse rescue ex : Clip :: Error puts ex return end if command .is_a? ( Clip :: Mapper :: Help ) puts command . help else hello ( command . name , command . repeat ) end end def self . hello ( name , repeat ) repeat . times { puts \"Hello #{ name } \" } end end Myapplication . run $ shards build Dependencies are satisfied Building: myapplication $ ./bin/myapplication --repeat two Alice Error: option's value is invalid: --repeat","title":"Options types"}]}